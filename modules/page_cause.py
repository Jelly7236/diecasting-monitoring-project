# modules/page_cause.py
from shiny import ui, render, reactive
import pandas as pd
import numpy as np
import plotly.graph_objs as go
import ast
from math import sqrt

from .cause_data import load_quality_from_file, load_fault_samples, load_var_labels
from .cause_ui import page_ui
from .cause_viz import fig_html, build_shap_bar
from .cause_service import snapshot_filter

# ===== ê³ ì • íŒŒë¼ë¯¸í„° =====
NI = 60
SPLIT_DAY = pd.Timestamp("2019-03-12")     # 3/12ê¹Œì§€ Dtrain, ì´í›„ Ctest
DEFAULT_START = pd.Timestamp("2019-03-01").date()
DEFAULT_END   = pd.Timestamp("2019-03-12").date()
DATE_MIN = pd.Timestamp(DEFAULT_START)
DATE_MAX = pd.Timestamp(DEFAULT_END)

def _clamp_date_range(sd, ed):
    sd = pd.to_datetime(sd, errors="coerce")
    ed = pd.to_datetime(ed, errors="coerce")
    if pd.isna(sd) or pd.isna(ed):
        return sd, ed
    if sd < DATE_MIN: sd = DATE_MIN
    if sd > DATE_MAX: sd = DATE_MAX
    if ed < DATE_MIN: ed = DATE_MIN
    if ed > DATE_MAX: ed = DATE_MAX
    if sd > ed: sd, ed = ed, sd
    return sd, ed

def _norm_mold_code(val) -> str:
    """
    Normalize mold code strings so lookups work consistently.
    Removes trailing decimals generated by CSV parsing (e.g. '8412.0' -> '8412').
    """
    s = str(val).strip()
    if s.endswith(".0"):
        return s[:-2]
    return s

# ===== í•™ìŠµ ì†ŒìŠ¤ =====
PATHS = {
    "D8413": ["./data/D8413.csv", "/mnt/data/D8413.csv"],
    "D8576": ["./data/D8576.csv", "/mnt/data/D8576.csv"],
    "DTRAIN": ["./data/Dtrain.csv", "/mnt/data/Dtrain.csv"],
    "CTEST":  ["./data/Ctest.csv",  "/mnt/data/Ctest.csv"],
}
BASELINE_FILES_PER_MOLD = {"8413": "D8413", "8576": "D8576"}
DTRAIN_MOLDS = {"8722", "8412", "8917"}

# ğŸ‘‰ 8722/8917ì€ 4Ïƒ, ë‚˜ë¨¸ì§€ 3Ïƒ
SIGMA_POLICY = {"8722": 4.0, "8917": 4.0}

# ---------------- ìœ í‹¸ ----------------
def _read_csv_first(paths):
    for p in paths:
        try:
            df = pd.read_csv(p)
            if not df.empty:
                return df
        except Exception:
            pass
    return pd.DataFrame()

def _clean_common(df: pd.DataFrame) -> pd.DataFrame:
    ren = {
        "Date": "date", "DATE": "date",
        "MOLD": "mold_code", "Mold": "mold_code", "mold": "mold_code",
        "PassOrFail": "passorfail",
        "tryshot_signal": "tryshot_signal", "tryshot": "tryshot_signal",
        "Count": "count", "ShotNo": "count", "shot_no": "count", "shot": "count",
        "Time": "time", "timestamp": "time",
    }
    for k, v in ren.items():
        if k in df.columns and v not in df.columns:
            df = df.rename(columns={k: v})
    df["date"] = pd.to_datetime(df.get("date"), errors="coerce")
    df["time"] = df.get("time", "")
    df["count"] = pd.to_numeric(df.get("count"), errors="coerce")
    if "count" not in df.columns:
        df["count"] = np.arange(len(df))
    df["mold_code"] = df.get("mold_code", "UNKNOWN").astype(str)
    df["tryshot_signal"] = df.get("tryshot_signal", "")
    df["passorfail"] = pd.to_numeric(df.get("passorfail"), errors="coerce").fillna(0).astype(int)
    return df

def agresti_coull(x: int, n: int) -> float:
    return (x + 2) / (n + 4) if n > 0 else float("nan")

def learn_pbar_map() -> dict:
    out = {}
    # ì „ìš©(8413/8576)
    for mold, key in BASELINE_FILES_PER_MOLD.items():
        df = _clean_common(_read_csv_first(PATHS[key]))
        if df.empty:
            out[mold] = np.nan; continue
        g = df[df["mold_code"] == mold]
        A = g[g["tryshot_signal"] == "A"]
        out[mold] = agresti_coull(int((A["passorfail"] == 1).sum()), int(A.shape[0]))
    # Dtrain 3/01~3/12 (8722/8412/8917)
    dtrain = _clean_common(_read_csv_first(PATHS["DTRAIN"]))
    if not dtrain.empty:
        d = dtrain["date"]
        dtrain = dtrain[(d.dt.month == 3) & (d.dt.day >= 1) & (d.dt.day <= 12)]
        for mold in DTRAIN_MOLDS:
            g = dtrain[dtrain["mold_code"] == mold]
            A = g[g["tryshot_signal"] == "A"]
            out[mold] = agresti_coull(int((A["passorfail"] == 1).sum()), int(A.shape[0]))
    return out

def make_limits_no_lcl(pbar: float, n_i: int, k2: float = 2.0, k3: float = 3.0):
    if not pd.notna(pbar):
        return (np.nan, np.nan, np.nan)
    sigma = np.sqrt(pbar * (1 - pbar) / n_i)
    return (pbar, pbar + k2 * sigma, pbar + k3 * sigma)

def _build_time_axis(df: pd.DataFrame) -> pd.Series:
    dt = pd.to_datetime(df["date"].dt.date)
    if "time" in df.columns and df["time"].notna().any():
        tt = pd.to_datetime(df["time"], errors="coerce")
        dt = pd.to_datetime(df["date"].dt.date) \
           + pd.to_timedelta(tt.dt.hour.fillna(0).astype(int), "h") \
           + pd.to_timedelta(tt.dt.minute.fillna(0).astype(int), "m") \
           + pd.to_timedelta(tt.dt.second.fillna(0).astype(int), "s")
    off = pd.to_timedelta(pd.to_numeric(df["count"], errors="coerce").fillna(0).astype(int), "s")
    return dt + off

def _norm_status(v):
    if v is None: return None
    t = str(v).strip().lower()
    if t in {"í•˜í•œ","í•˜í•œì´íƒˆ","low","lower","lo"}:  return "low"
    if t in {"ìƒí•œ","ìƒí•œì´íƒˆ","high","upper","hi"}: return "high"
    return t

# ============================== UI ===============================
def ui_cause():
    return page_ui()

# ============================ SERVER =============================
def server_cause(input, output, session):
    # ìƒë‹¨(ì¹´ë“œ/í•„í„°)ì€ ë™ë£Œ ë²„ì „ ë¡œì§
    df_all = load_quality_from_file()
    df_fault = load_fault_samples()
    var_map = load_var_labels()

    # ----- ê¸°ë³¸ ë‚ ì§œ: 3/01 ~ 3/12 ë¡œ ì´ˆê¸°í™” -----
    session.send_input_message("p_start", {"value": str(DEFAULT_START)})
    session.send_input_message("p_end",   {"value": str(DEFAULT_END)})

    # ----- ëª°ë“œ ì„ íƒ(â€œì „ì²´â€ í¬í•¨) -----
    @render.ui
    def p_mold_ui():
        molds_all_ctest = set()
        if not df_all.empty and "mold_code" in df_all.columns:
            molds_all_ctest = set(df_all["mold_code"].dropna().astype(str).str.strip().unique())

        molds_all_dtrain = set()
        dtrain_full = _read_csv_first(PATHS["DTRAIN"])
        if not dtrain_full.empty:
            dtrain_full = _clean_common(dtrain_full)
            molds_all_dtrain = set(dtrain_full["mold_code"].dropna().astype(str).str.strip().unique())

        molds = sorted(list(
            molds_all_ctest | molds_all_dtrain | set(BASELINE_FILES_PER_MOLD.keys()) | DTRAIN_MOLDS
        ))
        return ui.input_select("p_mold", "ëª°ë“œ", choices=["ì „ì²´"] + molds,
                               selected=(molds[0] if molds else "ì „ì²´"),
                               multiple=False)

    # ----- ìµœì‹  ë‚ ì§œ ë²„íŠ¼: ì¢…ë£Œì¼ì„ ë°ì´í„° ìµœì‹ ì¼ë¡œ -----
    @reactive.effect
    @reactive.event(input.btn_update_date)
    def _update_end():
        session.send_input_message("p_end", {"value": str(DEFAULT_END)})

    # ----- Dtrain + Ctest ê²°í•© ë°ì´í„°(ê¸°ê°„ í•„í„°) -----
    @reactive.calc
    @reactive.event(input.btn_apply)
    def data_in_period() -> pd.DataFrame:
        if not input.p_start() or not input.p_end():
            return pd.DataFrame()
        sd = pd.to_datetime(input.p_start()); ed = pd.to_datetime(input.p_end())
        sd, ed = _clamp_date_range(sd, ed)

        parts = []
        dtrain = _read_csv_first(PATHS["DTRAIN"])
        if not dtrain.empty and sd <= SPLIT_DAY:
            dtrain = _clean_common(dtrain)
            parts.append(dtrain[(dtrain["date"] >= sd) & (dtrain["date"] <= min(ed, SPLIT_DAY))])

        if not df_all.empty and ed > SPLIT_DAY:
            parts.append(df_all[(df_all["date"] > SPLIT_DAY) & (df_all["date"] <= ed)])

        if not parts:
            return pd.DataFrame()

        base = pd.concat(parts, ignore_index=True)
        base = base[(base["date"] >= sd) & (base["date"] <= ed)].copy()
        if "mold_code" in base.columns:
            base["mold_code"] = base["mold_code"].astype(str).map(_norm_mold_code)
        return base

    # ----- ê³µí†µ í•„í„°(â€˜ì „ì²´â€™ or ëª°ë“œ í•„í„°) -----
    @reactive.calc
    @reactive.event(input.btn_apply)
    def filt() -> pd.DataFrame:
        base_data = data_in_period()
        if base_data.empty:
            return pd.DataFrame()
        if input.p_mold() in (None, "ì „ì²´"):
            return base_data
        target = _norm_mold_code(input.p_mold())
        mold_series = base_data.get("mold_code")
        if mold_series is None:
            return pd.DataFrame()
        mask = mold_series.astype(str).map(_norm_mold_code) == target
        return base_data[mask].copy()

    # ----- ì„ íƒ ìš”ì•½ -----
    @render.text
    @reactive.event(input.btn_apply)
    def sel_summary():
        if not input.p_start() or not input.p_end():
            return "ì„ íƒê°’ì´ ì—†ìŠµë‹ˆë‹¤."
        sd_ts, ed_ts = _clamp_date_range(pd.to_datetime(input.p_start()), pd.to_datetime(input.p_end()))
        if pd.isna(sd_ts) or pd.isna(ed_ts):
            return "ì„ íƒê°’ì´ ì—†ìŠµë‹ˆë‹¤."
        sd = sd_ts.date()
        ed = ed_ts.date()
        mold_txt = "ì „ì²´ ëª°ë“œ" if input.p_mold() == "ì „ì²´" else f"ëª°ë“œ {input.p_mold()}"
        return f"[ì„ íƒ] {mold_txt} | ê¸°ê°„: {sd} ~ {ed}"

    # ========== (A) ëª°ë“œë³„ ëˆ„ì  í˜„í™©(ë™ë£Œ) ==========
    def _count_pchart_violations(df_mold_period: pd.DataFrame, mold: str) -> int:
        if df_mold_period.empty:
            return 0
        pbar = learn_pbar_map().get(str(mold), np.nan)
        if not pd.notna(pbar):
            return 0
        k3 = SIGMA_POLICY.get(str(mold), 3.0)
        _, _, UCL3 = make_limits_no_lcl(pbar, NI, k2=2.0, k3=k3)
        dfm = df_mold_period.sort_values([c for c in ["date","time","count"] if c in df_mold_period.columns], kind="mergesort").copy()
        is_A = dfm["tryshot_signal"].eq("A")
        idx_A = dfm.index[is_A]
        roll_def = (dfm.loc[is_A, "passorfail"] == 1).astype(int).rolling(NI, min_periods=NI).sum()
        dfm["p_hat"] = np.nan
        dfm.loc[idx_A[roll_def.notna()], "p_hat"] = roll_def.dropna().to_numpy() / NI
        ser = dfm.dropna(subset=["p_hat"])
        if ser.empty: return 0
        return int((ser["p_hat"] >= UCL3).sum())

    @render.ui
    @reactive.event(input.btn_apply)
    def mold_cards():
        if not input.p_start() or not input.p_end():
            return ui.div("ê¸°ê°„ì„ ì„ íƒí•˜ì„¸ìš”.", style="text-align:center; padding:24px; color:#6b7280;")
        sd = pd.to_datetime(input.p_start()); ed = pd.to_datetime(input.p_end())
        sd, ed = _clamp_date_range(sd, ed)

        molds_all_ctest = set()
        if not df_all.empty and "mold_code" in df_all.columns:
            molds_all_ctest = {_norm_mold_code(v) for v in df_all["mold_code"].dropna()}
        molds_all_dtrain = set()
        dtrain_full = _read_csv_first(PATHS["DTRAIN"])
        if not dtrain_full.empty:
            dtrain_full = _clean_common(dtrain_full)
            molds_all_dtrain = {_norm_mold_code(v) for v in dtrain_full["mold_code"].dropna()}
        molds_union = (
            molds_all_ctest
            | molds_all_dtrain
            | {_norm_mold_code(k) for k in BASELINE_FILES_PER_MOLD.keys()}
            | {_norm_mold_code(k) for k in DTRAIN_MOLDS}
        )
        molds_to_display = sorted(molds_union)
        if not molds_to_display:
            return ui.div("í‘œì‹œí•  ëª°ë“œ ì •ë³´ê°€ ì—†ìŠµë‹ˆë‹¤.", style="text-align:center; padding:24px; color:#6b7280;")

        base = data_in_period()

        fault_counts = {}
        fault_src = load_fault_samples()
        if not fault_src.empty:
            fault_period = fault_src.copy()
            fault_period["date"] = pd.to_datetime(fault_period.get("date"), errors="coerce")
            fault_period = fault_period[(fault_period["date"] >= sd) & (fault_period["date"] <= ed)]

            mold_series = fault_period.get("mold_code")
            if mold_series is not None:
                fault_period["mold_code"] = mold_series.map(_norm_mold_code)
            else:
                fault_period["mold_code"] = ""

            def _calc_fault_count(df_fault: pd.DataFrame) -> int:
                if df_fault.empty:
                    return 0
                if "passorfail" in df_fault.columns:
                    pf = pd.to_numeric(df_fault["passorfail"], errors="coerce").fillna(0)
                    if not pf.empty:
                        gt_zero = int((pf > 0).sum())
                        summed = float(pf.clip(lower=0).sum())
                        return max(int(round(summed)), gt_zero)
                return int(df_fault.shape[0])

            if not fault_period.empty:
                for mold_key, grp in fault_period.groupby("mold_code"):
                    fault_counts[_norm_mold_code(mold_key)] = _calc_fault_count(grp)

        def _card(mold: str):
            mold_key = _norm_mold_code(mold)
            if base.empty or "mold_code" not in base.columns:
                sub = pd.DataFrame()
            else:
                mask = base["mold_code"].astype(str).map(_norm_mold_code) == mold_key
                sub = base[mask].copy()
            fault_cnt = max(int(fault_counts.get(mold_key, 0)), 0)

            if sub.empty:
                return ui.card(
                    ui.card_header(f"ëª°ë“œ {mold}"),
                    ui.div(
                        ui.div("ëˆ„ì  ë¶ˆëŸ‰ë¥ ", style="text-align:center; color:#6b7280; font-weight:600;"),
                        ui.div("N/A", style="text-align:center; font-weight:800; font-size:26px; color:#9ca3af;"),
                        style="padding:8px 0;"
                    ),
                    ui.div(
                        ui.div(
                            ui.span(f"ëˆ„ì  ë¶ˆëŸ‰ {fault_cnt:,} ê±´"),
                            style="text-align:center; font-size:13px; font-weight:700;"
                        ),
                        style="padding:4px 0 8px 0;"
                    ),
                    style="flex:1 1 260px; min-width:240px; background-color:#f9fafb; opacity:0.8;"
                )

            n_all = int(sub.shape[0]); d_all = int((sub["passorfail"] == 1).sum())
            rate_all = (d_all / n_all * 100.0) if n_all > 0 else 0.0

            return ui.card(
                ui.card_header(f"ëª°ë“œ {mold}"),
                ui.div(
                    ui.div("ëˆ„ì  ë¶ˆëŸ‰ë¥ ", style="text-align:center; color:#6b7280; font-weight:600;"),
                    ui.div(f"{rate_all:,.2f}%", style="text-align:center; font-weight:800; font-size:26px; color:#1f60c4;"),
                    style="padding:8px 0;"
                ),
                ui.div(
                    ui.div(
                        ui.span(f"ëˆ„ì  ë¶ˆëŸ‰ {fault_cnt:,} ê±´"),
                        style="text-align:center; font-size:13px; font-weight:700;"
                    ),
                    style="padding:4px 0 8px 0;"
                ),
                style="flex:1 1 260px; min-width:240px;"
            )

        return ui.div(
            *[_card(m) for m in molds_to_display],
            style="display:flex; gap:12px; justify-content:flex-start; flex-wrap:nowrap; margin:0 auto; overflow-x:auto; padding-bottom:10px;"
        )

    # ======================= (ë¶„ì„ë¶€í„° ì•„ë˜ëŠ” ê¸°ì¡´ ìœ ì§€) =======================

    # ========== (B) p-ê´€ë¦¬ë„ ==========  â€” ìƒ‰ìƒ/ì ì„  ìŠ¤íƒ€ì¼ ì ìš©
    @render.ui
    @reactive.event(input.btn_apply)
    def p_chart():
        mold_sel = input.p_mold()
        if mold_sel in (None, ""):
            return ui.div("ëª°ë“œë¥¼ ì„ íƒí•˜ì„¸ìš”.", style="padding:12px; color:#6b7280;")
        mold = str(mold_sel)
        mold_norm = _norm_mold_code(mold)
        sd = pd.to_datetime(input.p_start()); ed = pd.to_datetime(input.p_end())
        sd, ed = _clamp_date_range(sd, ed)

        df = filt()
        if df.empty:
            fig = go.Figure(); fig.add_annotation(text="ì„ íƒí•œ ì¡°ê±´ì˜ ë°ì´í„°ê°€ ì—†ìŠµë‹ˆë‹¤.", showarrow=False)
            fig.update_layout(template="plotly_white", height=420)
            return fig_html(fig, 420)

        if mold == "ì „ì²´":
            fault_df = fault_filt()
            if fault_df.empty or ("ë©”ì‹œì§€" in fault_df.columns and len(fault_df.columns) == 1):
                return ui.div(
                    "ì„ íƒí•œ ê¸°ê°„ì— ë¶ˆëŸ‰ ë¡œê·¸ê°€ ì—†ì–´ ì „ì²´ ëª°ë“œ p-ê´€ë¦¬ë„ë¥¼ ê·¸ë¦´ ìˆ˜ ì—†ìŠµë‹ˆë‹¤.",
                    style="padding:12px; color:#6b7280;"
                )
            mold_col = fault_df.get("mold_code")
            if mold_col is not None:
                mold_series = mold_col.dropna().astype(str)
            else:
                mold_series = pd.Series(dtype=str)
            molds_focus = sorted({_norm_mold_code(m) for m in mold_series})
            if molds_focus:
                df = df[df["mold_code"].astype(str).map(_norm_mold_code).isin(molds_focus)]
            if df.empty:
                return ui.div(
                    "ì„ íƒí•œ ê¸°ê°„ì˜ ë¶ˆëŸ‰ ë¡œê·¸ì™€ ì¼ì¹˜í•˜ëŠ” í’ˆì§ˆ ë°ì´í„°ê°€ ì—†ìŠµë‹ˆë‹¤.",
                    style="padding:12px; color:#6b7280;"
                )
        else:
            if "mold_code" in df.columns:
                mask = df["mold_code"].astype(str).map(_norm_mold_code) == mold_norm
                df = df[mask]
            if df.empty:
                fig = go.Figure(); fig.add_annotation(text="ì„ íƒí•œ ëª°ë“œì˜ ë°ì´í„°ê°€ ì—†ìŠµë‹ˆë‹¤.", showarrow=False)
                fig.update_layout(template="plotly_white", height=420)
                return fig_html(fig, 420)

        df = df.sort_values([c for c in ["date","time","count"] if c in df.columns], kind="mergesort")
        df["_ts"] = _build_time_axis(df)

        is_A = df["tryshot_signal"].eq("A")
        idx_A = df.index[is_A]
        roll_def = (df.loc[is_A, "passorfail"] == 1).astype(int).rolling(window=NI, min_periods=NI).sum()
        df["p_hat"] = np.nan
        df.loc[idx_A[roll_def.notna()], "p_hat"] = roll_def.dropna().to_numpy() / NI

        ser = df.dropna(subset=["p_hat"]).copy()
        if ser.empty:
            fig = go.Figure(); fig.add_annotation(text="ë¡¤ë§ ì°½(60ìƒ·)ì„ ì¶©ì¡±í•˜ëŠ” A ì‹œê·¸ë„ì´ ì—†ìŠµë‹ˆë‹¤.", showarrow=False)
            fig.update_layout(template="plotly_white", height=420)
            return fig_html(fig, 420)

        if mold == "ì „ì²´":
            pbar = pd.to_numeric(df.loc[is_A, "passorfail"], errors="coerce").mean()
            if not pd.notna(pbar):
                fig = go.Figure(); fig.add_annotation(text="ì „ì²´ ëª°ë“œ ê¸°ì¤€ pÌ„ ê°’ì´ ê³„ì‚°ë˜ì§€ ì•Šì•˜ìŠµë‹ˆë‹¤.", showarrow=False)
                fig.update_layout(template="plotly_white", height=420)
                return fig_html(fig, 420)
            k3 = 3.0
            title_txt = f"ì „ì²´ ëª°ë“œ í†µí•© p-ê´€ë¦¬ë„ (n={NI})"
            y_title = "pÌ‚(ìµœê·¼ ë¶ˆëŸ‰ë¥ )"
        else:
            pbar = learn_pbar_map().get(mold_norm, np.nan)
            if not pd.notna(pbar):
                fig = go.Figure(); fig.add_annotation(text="í•´ë‹¹ ëª°ë“œì˜ ê¸°ì¤€ pÌ„ì„ í•™ìŠµí•  ìˆ˜ ì—†ìŠµë‹ˆë‹¤.", showarrow=False)
                fig.update_layout(template="plotly_white", height=420)
                return fig_html(fig, 420)
            k3 = SIGMA_POLICY.get(mold_norm, 3.0)
            title_txt = f"ëª°ë“œ {mold} p-ê´€ë¦¬ë„ (n={NI})"
            y_title = f"pÌ‚(êµ¬ê°„ n={NI} ë¶ˆëŸ‰ë¥ )"
        CL, UCL2, UCL3 = make_limits_no_lcl(pbar, NI, k2=2.0, k3=k3)

        fig = go.Figure()
        # ì¶”ì„¸ì„ (í•˜ëŠ˜ìƒ‰)
        fig.add_trace(go.Scatter(
            x=ser["_ts"], y=ser["p_hat"], mode="lines",
            line=dict(color="#60A5FA", width=1.6),
            name="pÌ‚ trend", hoverinfo="skip"
        ))
        # CAUTION / CRITICAL
        cau = ser[(ser["p_hat"] >= UCL2) & (ser["p_hat"] < UCL3)]
        if not cau.empty:
            fig.add_trace(go.Scatter(
                x=cau["_ts"], y=cau["p_hat"], mode="markers",
                marker=dict(size=7, color="#F59E0B"),
                name="CAUTION",
                hovertemplate="ì‹œê°:%{x|%Y-%m-%d %H:%M:%S}<br>pÌ‚:%{y:.4f}<extra></extra>"
            ))
        crit = ser[ser["p_hat"] >= UCL3]
        if not crit.empty:
            fig.add_trace(go.Scatter(
                x=crit["_ts"], y=crit["p_hat"], mode="markers",
                marker=dict(size=8, color="#EF4444"),
                name="CRITICAL",
                hovertemplate="ì‹œê°:%{x|%Y-%m-%d %H:%M:%S}<br>pÌ‚:%{y:.4f}<extra></extra>"
            ))
        # ê¸°ì¤€ì„ (ì ì„ )
        fig.add_hline(y=CL,   line=dict(color="#1D4ED8", width=2), line_dash="dot",
                      annotation_text=f"CL ({CL:.3f})", annotation_position="right")
        fig.add_hline(y=UCL2, line=dict(color="#F59E0B", width=2), line_dash="dot",
                      annotation_text=f"UCL2 (2Ïƒ, {UCL2:.3f})", annotation_position="right")
        fig.add_hline(y=UCL3, line=dict(color="#EF4444", width=2), line_dash="dot",
                      annotation_text=f"UCL3 ({int(k3)}Ïƒ, {UCL3:.3f})", annotation_position="right")
        fig.update_layout(template="plotly_white", height=420,
                          title=title_txt,
                          hovermode="x unified", margin=dict(l=40, r=20, t=40, b=40),
                          xaxis_title="ì‹œê°„", yaxis_title=y_title,
                          legend=dict(orientation="h", yanchor="bottom", y=1.02, xanchor="right", x=1))
        return fig_html(fig, 420)

    # ========== (C) SHAP ì¤‘ìš” ë³€ìˆ˜ ê¸°ì—¬ë„ ==========  â€” âœ… ë™ë£Œ ë²„ì „ ì±„íƒ
    # ========== (C) SHAP ì¤‘ìš” ë³€ìˆ˜ ê¸°ì—¬ë„ ==========  â€” fault_analysis_dataframe_filtered.csv ê¸°ë°˜ (ìµœì†Œ ìˆ˜ì •)
    @render.ui
    @reactive.event(input.btn_apply)
    def shap_plot():
        mold_sel = input.p_mold()
        if mold_sel is None:
            return ui.div(
                "ëª°ë“œë¥¼ ì„ íƒí•˜ì„¸ìš”.",
                style="color:#6b7280; padding:12px; height: 420px; display:flex; align-items:center; justify-content:center;"
            )

        # ë¶ˆëŸ‰ ìƒ˜í”Œ ë¡œê·¸(ë™ë£Œ ì½”ë“œì˜ ë°ì´í„° ê²½ë¡œ) ì‚¬ìš© â€” ì—¬ê¸°ì„œ fault_analysis_dataframe_filtered.csvê°€ ë¡œë“œë¨
        dff = fault_filt()
        if dff.empty or ("ë©”ì‹œì§€" in dff.columns and len(dff.columns) == 1):
            return ui.div(
                "ì„ íƒí•œ ëª°ë“œ/ê¸°ê°„ì— SHAP ë°ì´í„°ê°€ ì—†ìŠµë‹ˆë‹¤.",
                style="color:#6b7280; padding:12px; height: 420px; display:flex; align-items:center; justify-content:center;"
            )

        # 1) CSV ë‚´ ëª¨ë“  *_shap ì»¬ëŸ¼ ìë™ íƒì§€
        shap_cols = [c for c in dff.columns if isinstance(c, str) and c.lower().endswith("_shap")]
        if not shap_cols:
            return ui.div(
                "ë°ì´í„°ì— *_shap ì»¬ëŸ¼ì´ ì—†ì–´ SHAP ì¤‘ìš”ë„ë¥¼ ê³„ì‚°í•  ìˆ˜ ì—†ìŠµë‹ˆë‹¤.",
                style="color:#6b7280; padding:12px; height: 420px; display:flex; align-items:center; justify-content:center;"
            )

        # 2) ì „ì—­ ì¤‘ìš”ë„: ê° ë³€ìˆ˜ SHAPì˜ |ê°’| í‰ê· 
        df_shap = dff[shap_cols].apply(pd.to_numeric, errors="coerce")
        imp = df_shap.abs().mean(axis=0, skipna=True)  # Series(index=*_shap, value=abs-mean)

        # 3) ë³€ìˆ˜ëª… ì •ë¦¬ ë° í•œê¸€ ë¼ë²¨ ë§¤í•‘
        def base_name(col):
            # ëì˜ "_shap" ì œê±°
            name = col[:-5] if col.lower().endswith("_shap") else col
            # var_labels.csv ë§¤í•‘ (ì†Œë¬¸ì í‚¤ë„ ëŒ€ì‘)
            return var_map.get(name, var_map.get(name.lower(), name))

        imp_df = (
            imp.rename(index=base_name)
            .reset_index()
            .rename(columns={"index": "ë³€ìˆ˜", 0: "ì¤‘ìš”ë„"})
            .sort_values("ì¤‘ìš”ë„", ascending=False)
        )

        # 4) ìƒìœ„ 15ê°œë§Œ ì‹œê°í™” (ìˆ˜ëŸ‰ì€ í•„ìš” ì‹œ ì¡°ì ˆ ê°€ëŠ¥)
        topn = imp_df.head(15).reset_index(drop=True)
        values = topn["ì¤‘ìš”ë„"].astype(float)
        if not values.empty and values.max() != values.min():
            marker_style = dict(
                color=values.tolist(),
                colorscale=[(0.0, "#BFDBFE"), (1.0, "#1D4ED8")],
                showscale=False
            )
        else:
            marker_style = dict(color="#1D4ED8")

        # 5) Plotly ë°”ì°¨íŠ¸ (ê°€ë…ì„± ìœ„í•´ ê°€ë¡œë§‰ëŒ€)
        fig = go.Figure()
        fig.add_trace(go.Bar(
            x=topn["ì¤‘ìš”ë„"].values.tolist(),
            y=topn["ë³€ìˆ˜"].values.tolist(),
            orientation="h",
            hovertemplate="%{y}<br>í‰ê·  |SHAP|: %{x:.5f}<extra></extra>",
            marker=marker_style
        ))
        fig.update_layout(
            template="plotly_white",
            height=420,
            margin=dict(l=120, r=20, t=30, b=40),
            title=f"SHAP ì¤‘ìš” ë³€ìˆ˜ ê¸°ì—¬ë„ (í‰ê·  |SHAP|){' - ì „ì²´ ëª°ë“œ' if mold_sel == 'ì „ì²´' else f' - ëª°ë“œ {mold_sel}'}",
            xaxis_title="í‰ê·  |SHAP|",
            yaxis_title="ë³€ìˆ˜",
            yaxis=dict(
                categoryorder="array",
                categoryarray=topn["ë³€ìˆ˜"].tolist(),
                autorange="reversed"
            ),
            showlegend=False
        )

        return fig_html(fig, 420)


    # ========== (D) ì‹¤ì œ ë¶ˆëŸ‰ ìƒ˜í”Œ ë¡œê·¸ ==========  â€” ê¸°ì¡´ ìœ ì§€
    def _ko_var(text: str) -> str:
        if not isinstance(text, str): return text
        s = text.strip()
        if ":" in s:
            h, t = s.split(":", 1)
            return f"{var_map.get(h.strip(), h.strip())}: {t.strip()}"
        return var_map.get(s, s)

    @reactive.calc
    @reactive.event(input.btn_apply)
    def fault_filt():
        if not input.p_start() or not input.p_end():
            return pd.DataFrame({"ë©”ì‹œì§€": ["ê¸°ê°„ì„ ì„ íƒí•˜ì„¸ìš”."]})
        df = load_fault_samples().copy()
        if df.empty:
            return pd.DataFrame({"ë©”ì‹œì§€": ["ë¶ˆëŸ‰ ìƒ˜í”Œ CSVê°€ ë¹„ì–´ìˆìŠµë‹ˆë‹¤."]})
        sd = pd.to_datetime(input.p_start()); ed = pd.to_datetime(input.p_end())
        if sd > ed: sd, ed = ed, sd
        df["date"] = pd.to_datetime(df.get("date"), errors="coerce")
        df = df[(df["date"] >= sd) & (df["date"] <= ed)]
        mold_series = df.get("mold_code")
        if mold_series is not None:
            df["mold_code"] = mold_series.astype(str).map(_norm_mold_code)
        if input.p_mold() not in (None, "ì „ì²´"):
            if "mold_code" not in df.columns:
                return pd.DataFrame({"ë©”ì‹œì§€": ["CSVì— ëª°ë“œ ì½”ë“œê°€ ì—†ìŠµë‹ˆë‹¤."]})
            df = df[df["mold_code"] == _norm_mold_code(input.p_mold())]
        return df.sort_values("date").reset_index(drop=True)

    @render.ui
    @reactive.event(input.btn_apply)
    def detect_log():
        df = fault_filt()
        if df.empty or ("ë©”ì‹œì§€" in df.columns and len(df.columns) == 1):
            return ui.HTML(f'<div style="max-height:280px; overflow:auto">{pd.DataFrame(df).to_html(index=False)}</div>')

        def pick(cands):
            low = {c.lower(): c for c in df.columns}
            for n in cands:
                if n.lower() in low: return low[n.lower()]
            return None

        k_date  = pick(["date","ì¼ì‹œ","datetime","timestamp","time"])
        k_mold  = pick(["mold_code","mold","ëª°ë“œ"])
        k_count = pick(["count","ìˆœë²ˆ","index","shot_no","shotno"])
        k_rfp   = pick(["rf_prediction","ì˜ˆì¸¡ë¶ˆëŸ‰ë„","rf_pred"])
        k_rfpb  = pick(["rf_probability","ì˜ˆì¸¡ë¶ˆëŸ‰í™•ë¥ ","prob","probability"])
        k_s1    = pick(["shap1"]); k_s2 = pick(["shap2"])
        k_s1st  = pick(["shap1_status","shap1ë³€ìˆ˜ìƒíƒœ"])
        k_s2st  = pick(["shap2_status","shap2ë³€ìˆ˜ìƒíƒœ"])
        k_cut   = pick(["cutoff","ì´íƒˆë³€ìˆ˜"])
        k_if    = pick(["if_prediction","ì´ìƒíƒì§€"])
        k_ifas  = pick(["if_anomaly_score","anomalyscore","anomaly_score"])

        def ensure(src): return df[src] if src is not None else pd.Series([None]*len(df))
        out = pd.DataFrame({
            "ì¼ì‹œ": pd.to_datetime(ensure(k_date), errors="coerce"),
            "ëª°ë“œ": ensure(k_mold).astype(str) if k_mold else pd.Series([None]*len(df)),
            "ìˆœë²ˆ": pd.to_numeric(ensure(k_count), errors="coerce"),
            "ì˜ˆì¸¡ë¶ˆëŸ‰ë„": pd.to_numeric(ensure(k_rfp),  errors="coerce"),
            "ì˜ˆì¸¡ë¶ˆëŸ‰í™•ë¥ ": pd.to_numeric(ensure(k_rfpb), errors="coerce"),
            "shap1": ensure(k_s1), "shap2": ensure(k_s2),
            "shap1ë³€ìˆ˜ìƒíƒœ": ensure(k_s1st), "shap2ë³€ìˆ˜ìƒíƒœ": ensure(k_s2st),
            "ì´íƒˆë³€ìˆ˜": ensure(k_cut),
            "ì´ìƒíƒì§€": ensure(k_if),
            "AnomalyScore": pd.to_numeric(ensure(k_ifas), errors="coerce"),
        })

        for c in ["shap1","shap2"]:
            if c in out: out[c] = out[c].map(_ko_var)
        for c in ["shap1ë³€ìˆ˜ìƒíƒœ","shap2ë³€ìˆ˜ìƒíƒœ"]:
            if c in out: out[c] = out[c].map(_norm_status)

        def fmt_cut(cell):
            if cell is None or (isinstance(cell, float) and pd.isna(cell)): return None
            try:
                d = cell if isinstance(cell, dict) else (ast.literal_eval(str(cell)) if str(cell).strip() else None)
            except Exception:
                d = None
            if not isinstance(d, dict): return str(cell)
            items = [f"{var_map.get(str(k).strip(), str(k).strip())}: {_norm_status(v)}" for k, v in d.items()]
            return "<br>".join(items)

        if "ì´íƒˆë³€ìˆ˜" in out: out["ì´íƒˆë³€ìˆ˜"] = out["ì´íƒˆë³€ìˆ˜"].map(fmt_cut)
        if out["ì¼ì‹œ"].notna().any(): out = out.sort_values("ì¼ì‹œ").reset_index(drop=True)
        if "ì˜ˆì¸¡ë¶ˆëŸ‰í™•ë¥ " in out: out["ì˜ˆì¸¡ë¶ˆëŸ‰í™•ë¥ "] = out["ì˜ˆì¸¡ë¶ˆëŸ‰í™•ë¥ "].round(4)
        if "AnomalyScore" in out:  out["AnomalyScore"]  = out["AnomalyScore"].round(3)

        def map_if(x):
            s = str(x).strip().lower()
            if s in {"1","true","yes","y","anomaly","abnormal","ì´ìƒ"}: return "ì´ìƒ"
            if s in {"0","false","no","n","normal","ì •ìƒ"}:            return "ì •ìƒ"
            return None
        if "ì´ìƒíƒì§€" in out: out["ì´ìƒíƒì§€"] = out["ì´ìƒíƒì§€"].map(map_if)

        html = out.to_html(index=False, border=0, classes="tbl-sample-log", escape=False)
        html = html.replace(">\n<thead", ">\n<caption>ì‹¤ì œ ë¶ˆëŸ‰ ìƒ˜í”Œ ë¡œê·¸</caption>\n<thead", 1)
        return ui.HTML(f"""
        <style>
        .tbl-wrap {{ max-height:280px; overflow-y:auto; border:1px solid #e5e7eb; border-radius:6px; }}
        table.tbl-sample-log {{ width:100%; table-layout:fixed; border-collapse:collapse; font-size:13px; }}
        table.tbl-sample-log caption {{ caption-side:top; text-align:center; font-weight:700; padding:6px 0 4px; }}
        table.tbl-sample-log thead th {{ text-align:left; position:sticky; top:0; background:#fff; z-index:1; border-bottom:1px solid #e5e7eb; padding:8px 10px; font-weight:700; }}
        table.tbl-sample-log tbody td {{ text-align:left; vertical-align:top; padding:8px 10px; border-bottom:1px solid #f1f5f9; word-break:break-word; font-variant-numeric:tabular-nums; }}
        </style>
        <div class="tbl-wrap">{html}</div>
        """)

    # âœ… CSV ë‹¤ìš´ë¡œë“œ (ìƒ˜í”Œ ë¡œê·¸ ê·¸ëŒ€ë¡œ ì €ì¥)
    @render.download(filename=lambda: f"sample_log_{input.p_mold() or 'ALL'}_{input.p_start() or 'NA'}_{input.p_end() or 'NA'}.csv")
    def btn_report():
        df = fault_filt()
        yield df.to_csv(index=False, encoding="utf-8-sig").encode("utf-8-sig")

    # ========== (E) ë³€ìˆ˜ë³„ ê´€ê³„ë¶„ì„(TOP5) â€” Score ìœ ì§€ ==========
    @reactive.calc
    @reactive.event(input.btn_apply)
    def var_relation_df():
        df = fault_filt()
        if df.empty or ("ë©”ì‹œì§€" in df.columns and len(df.columns) == 1):
            return pd.DataFrame(columns=["ë³€ìˆ˜","ìƒíƒœ","shap","high","low","Score","rank"])

        def pick(cands):
            low = {c.lower(): c for c in df.columns}
            for n in cands:
                if n.lower() in low: return low[n.lower()]
            return None

        k_cut = pick(["cutoff","ì´íƒˆë³€ìˆ˜"])
        k_s1, k_s2 = pick(["shap1"]), pick(["shap2"])
        k_s1st = pick(["shap1_status","shap1ë³€ìˆ˜ìƒíƒœ"])
        k_s2st = pick(["shap2_status","shap2ë³€ìˆ˜ìƒíƒœ"])

        def nstat(v):
            t = str(v).strip().lower()
            if t in {"í•˜í•œ","í•˜í•œì´íƒˆ","low","lower","lo"}: return "low"
            if t in {"ìƒí•œ","ìƒí•œì´íƒˆ","high","upper","hi"}: return "high"
            return None

        cutoff, shap = {}, {}
        if k_cut:
            for cell in df[k_cut]:
                if cell is None or (isinstance(cell,float) and pd.isna(cell)): continue
                try:
                    d = cell if isinstance(cell, dict) else (ast.literal_eval(str(cell)) if str(cell).strip() else None)
                except Exception:
                    d = None
                if not isinstance(d, dict): continue
                for k, v in d.items():
                    st = nstat(v)
                    if st not in {"low","high"}: continue
                    vko = var_map.get(str(k).strip(), str(k).strip())
                    cutoff[(vko, st)] = cutoff.get((vko, st), 0) + 1

        def add_shap(name_val, status_val):
            if not isinstance(name_val, str) or status_val is None: return
            var_name = name_val.split(":",1)[0].strip()
            vko = var_map.get(var_name, var_name)
            st  = nstat(status_val)
            if st not in {"low","high"}: return
            shap[(vko, st)] = shap.get((vko, st), 0) + 1

        for _, r in df.iterrows():
            if k_s1: add_shap(r.get(k_s1), r.get(k_s1st))
            if k_s2: add_shap(r.get(k_s2), r.get(k_s2st))

        vars_all = set(v for v,_ in cutoff.keys()) | set(v for v,_ in shap.keys())
        rows = []
        for v in vars_all:
            for st in ["high","low"]:
                s = shap.get((v,st), 0)
                h = cutoff.get((v,"high"), 0) if st == "high" else 0
                l = cutoff.get((v,"low"),  0) if st == "low"  else 0
                rows.append({"ë³€ìˆ˜": v, "ìƒíƒœ": st, "shap": s, "high": h, "low": l, "Score": s + h + l})

        out = pd.DataFrame(rows)
        if out.empty:
            return pd.DataFrame(columns=["ë³€ìˆ˜","ìƒíƒœ","shap","high","low","Score","rank"])
        out = out.sort_values(["Score","shap","high","low"], ascending=[False,False,False,False]).reset_index(drop=True)
        out["rank"] = out.index + 1
        return out.head(5)

    @render.ui
    @reactive.event(input.btn_apply)
    def var_rel_table():
        df_top = var_relation_df()
        if df_top.empty:
            return ui.HTML('<div style="padding:8px;color:#6b7280;">ë°ì´í„°ê°€ ì—†ìŠµë‹ˆë‹¤.</div>')

        pretty = df_top[["rank","ë³€ìˆ˜","Score","ìƒíƒœ","shap","high","low"]].rename(columns={
            "rank":"Rank","ë³€ìˆ˜":"ë³€ìˆ˜","Score":"ì›ì¸ ê¸°ì—¬ íšŸìˆ˜","ìƒíƒœ":"ìƒíƒœ","shAP":"SHAPíšŸìˆ˜","high":"HIGHíšŸìˆ˜","low":"LOWíšŸìˆ˜"
        })
        # ì˜¤íƒ€ ë°©ì§€ ì¬ì •ì˜
        pretty = df_top[["rank","ë³€ìˆ˜","Score","ìƒíƒœ","shap","high","low"]].rename(columns={
            "rank":"Rank","ë³€ìˆ˜":"ë³€ìˆ˜","Score":"ì›ì¸ ê¸°ì—¬ íšŸìˆ˜","ìƒíƒœ":"ìƒíƒœ","shap":"SHAPíšŸìˆ˜","high":"HIGHíšŸìˆ˜","low":"LOWíšŸìˆ˜"
        })

        html = pretty.to_html(index=False, classes="var-rel-table", border=0)
        return ui.HTML(f"""
        <style>
        table.var-rel-table {{
            width: 100%;
            border-collapse: collapse;
            font-size: 14px;
        }}
        table.var-rel-table thead th {{
            text-align: left;
            border-bottom: 1px solid #e5e7eb;
            padding: 8px 10px;
            font-weight: 700;
        }}
        table.var-rel-table tbody td {{
            text-align: left;
            padding: 10px 10px;
            border-bottom: 1px solid #f1f5f9;
            font-variant-numeric: tabular-nums;
        }}
        td.rank-cell::before {{
            content: attr(data-rank);
            display: inline-block;
            min-width: 36px;
            text-align: center;
            background: #111827;
            color: #fff;
            border-radius: 16px;
            padding: 2px 10px;
            font-weight: 800;
            letter-spacing: 0.5px;
        }}
        td.rank-cell[data-rank="1"]::before {{ background:#D4AF37; color:#111; }}
        td.rank-cell[data-rank="2"]::before {{ background:#C0C0C0; color:#111; }}
        td.rank-cell[data-rank="3"]::before {{ background:#CD7F32; color:#111; }}
        td.state-cell[data-state="low"]  {{ color:#2E86C1; font-weight:700; }}
        td.state-cell[data-state="high"] {{ color:#E74C3C; font-weight:700; }}
        td.score-cell {{ font-weight: 900; font-size: 18px; letter-spacing: 0.2px; }}
        </style>
        {html}
        <script>
        (function(){{
            var tbl = document.querySelector('table.var-rel-table'); if(!tbl) return;
            var rows = tbl.tBodies[0]?.rows || [];
            Array.from(rows).forEach(function(row){{
                var rankTd = row.cells[0];
                if(rankTd){{
                    var rk=(rankTd.innerText||'').trim();
                    rankTd.setAttribute('data-rank',rk);
                    rankTd.classList.add('rank-cell');
                    rankTd.innerText='';
                }}
                var scoreTd = row.cells[2];
                if(scoreTd){{
                    scoreTd.classList.add('score-cell');
                }}
                var stateTd = row.cells[3];
                if(stateTd){{
                    var st=(stateTd.innerText||'').trim().toLowerCase();
                    stateTd.classList.add('state-cell');
                    stateTd.setAttribute('data-state',st);
                }}
            }});
        }})();
        </script>
        """)

    @render.ui
    @reactive.event(input.btn_apply)
    def var_rel_bar():
        df_top = var_relation_df()
        if df_top.empty:
            fig = go.Figure(); fig.add_annotation(text="ë°ì´í„° ì—†ìŒ", showarrow=False)
            fig.update_layout(template="plotly_white", height=340)
            return fig_html(fig, 340)

        # Xì¶•: "ë³€ìˆ˜ëª…(ë‹¨ìœ„ ì œê±°)\n(LOW/HIGH)" í˜•ì‹
        def norm_label(vname: str):
            s = str(vname)
            return s.split("(")[0].strip()

        x = df_top.apply(lambda r: f"{norm_label(r['ë³€ìˆ˜'])}\n({'HIGH' if r['ìƒíƒœ']=='high' else 'LOW'})", axis=1).tolist()
        y = df_top["Score"].tolist()
        colors = ["#E74C3C" if s == "high" else "#2E86C1" for s in df_top["ìƒíƒœ"]]

        fig = go.Figure()
        fig.add_trace(go.Bar(
            x=x, y=y, marker_color=colors,
            hovertemplate="%{x}<br>ì›ì¸ ê¸°ì—¬ íšŸìˆ˜: %{y}<extra></extra>",
            name=""
        ))
        # ìƒ‰ìƒ ë²”ë¡€(LOW/HIGH)
        fig.add_trace(go.Scatter(x=[None], y=[None], mode="markers",
                                 marker=dict(size=10, color="#2E86C1"), name="LOW"))
        fig.add_trace(go.Scatter(x=[None], y=[None], mode="markers",
                                 marker=dict(size=10, color="#E74C3C"), name="HIGH"))

        fig.update_layout(template="plotly_white", height=340,
                          margin=dict(l=40, r=20, t=30, b=70),
                          xaxis_title="ë³€ìˆ˜(ìƒíƒœ)",
                          yaxis_title="ì›ì¸ ê¸°ì—¬ íšŸìˆ˜",
                          legend=dict(orientation="h", yanchor="bottom", y=1.02, xanchor="right", x=1),
                        #   annotations=[dict(
                        #       x=0, y=-0.28, xref="paper", yref="paper",
                        #     #   text="ì›ì¸ ê¸°ì—¬ íšŸìˆ˜ = SHAPíšŸìˆ˜ + HIGHíšŸìˆ˜ + LOWíšŸìˆ˜",
                        #       showarrow=False, align="left", font=dict(color="#6b7280")
                        #   )]
                          )
        return fig_html(fig, 340)
