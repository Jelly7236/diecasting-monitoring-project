# modules/page_cause.py
from shiny import ui, render, reactive
import pandas as pd
import numpy as np
import plotly.graph_objs as go
import ast
from math import sqrt

from .cause_data import load_quality_from_file, load_fault_samples, load_var_labels
from .cause_ui import page_ui
from .cause_viz import fig_html, build_shap_bar
from .cause_service import snapshot_filter

# ===== Í≥†Ï†ï ÌååÎùºÎØ∏ÌÑ∞ =====
NI = 60
SPLIT_DAY = pd.Timestamp("2019-03-12")     # 3/12ÍπåÏßÄ Dtrain, Ïù¥ÌõÑ Ctest
DEFAULT_START = pd.Timestamp("2019-03-01").date()
DEFAULT_END   = pd.Timestamp("2019-03-12").date()
DATE_MIN = pd.Timestamp(DEFAULT_START)
DATE_MAX = pd.Timestamp(DEFAULT_END)

def _clamp_date_range(sd, ed):
    sd = pd.to_datetime(sd, errors="coerce")
    ed = pd.to_datetime(ed, errors="coerce")
    if pd.isna(sd) or pd.isna(ed):
        return sd, ed
    if sd < DATE_MIN: sd = DATE_MIN
    if sd > DATE_MAX: sd = DATE_MAX
    if ed < DATE_MIN: ed = DATE_MIN
    if ed > DATE_MAX: ed = DATE_MAX
    if sd > ed: sd, ed = ed, sd
    return sd, ed

def _norm_mold_code(val) -> str:
    """
    Normalize mold code strings so lookups work consistently.
    Removes trailing decimals generated by CSV parsing (e.g. '8412.0' -> '8412').
    """
    s = str(val).strip()
    if s.endswith(".0"):
        return s[:-2]
    return s

# ===== ÌïôÏäµ ÏÜåÏä§ =====
PATHS = {
    "D8413": ["./data/D8413.csv", "/mnt/data/D8413.csv"],
    "D8576": ["./data/D8576.csv", "/mnt/data/D8576.csv"],
    "DTRAIN": ["./data/Dtrain.csv", "/mnt/data/Dtrain.csv"],
    "CTEST":  ["./data/Ctest.csv",  "/mnt/data/Ctest.csv"],
}
BASELINE_FILES_PER_MOLD = {"8413": "D8413", "8576": "D8576"}
DTRAIN_MOLDS = {"8722", "8412", "8917"}

# üëâ 8722/8917ÏùÄ 4œÉ, ÎÇòÎ®∏ÏßÄ 3œÉ
SIGMA_POLICY = {"8722": 4.0, "8917": 4.0}

# ---------------- Ïú†Ìã∏ ----------------
def _read_csv_first(paths):
    for p in paths:
        try:
            df = pd.read_csv(p)
            if not df.empty:
                return df
        except Exception:
            pass
    return pd.DataFrame()

def _clean_common(df: pd.DataFrame) -> pd.DataFrame:
    ren = {
        "Date": "date", "DATE": "date",
        "MOLD": "mold_code", "Mold": "mold_code", "mold": "mold_code",
        "PassOrFail": "passorfail",
        "tryshot_signal": "tryshot_signal", "tryshot": "tryshot_signal",
        "Count": "count", "ShotNo": "count", "shot_no": "count", "shot": "count",
        "Time": "time", "timestamp": "time",
    }
    for k, v in ren.items():
        if k in df.columns and v not in df.columns:
            df = df.rename(columns={k: v})
    df["date"] = pd.to_datetime(df.get("date"), errors="coerce")
    df["time"] = df.get("time", "")
    df["count"] = pd.to_numeric(df.get("count"), errors="coerce")
    if "count" not in df.columns:
        df["count"] = np.arange(len(df))
    df["mold_code"] = df.get("mold_code", "UNKNOWN").astype(str)
    df["tryshot_signal"] = df.get("tryshot_signal", "")
    df["passorfail"] = pd.to_numeric(df.get("passorfail"), errors="coerce").fillna(0).astype(int)
    return df

def agresti_coull(x: int, n: int) -> float:
    return (x + 2) / (n + 4) if n > 0 else float("nan")

def learn_pbar_map() -> dict:
    out = {}
    # Ï†ÑÏö©(8413/8576)
    for mold, key in BASELINE_FILES_PER_MOLD.items():
        df = _clean_common(_read_csv_first(PATHS[key]))
        if df.empty:
            out[mold] = np.nan; continue
        g = df[df["mold_code"] == mold]
        A = g[g["tryshot_signal"] == "A"]
        out[mold] = agresti_coull(int((A["passorfail"] == 1).sum()), int(A.shape[0]))
    # Dtrain 3/01~3/12 (8722/8412/8917)
    dtrain = _clean_common(_read_csv_first(PATHS["DTRAIN"]))
    if not dtrain.empty:
        d = dtrain["date"]
        dtrain = dtrain[(d.dt.month == 3) & (d.dt.day >= 1) & (d.dt.day <= 12)]
        for mold in DTRAIN_MOLDS:
            g = dtrain[dtrain["mold_code"] == mold]
            A = g[g["tryshot_signal"] == "A"]
            out[mold] = agresti_coull(int((A["passorfail"] == 1).sum()), int(A.shape[0]))
    return out

def make_limits_no_lcl(pbar: float, n_i: int, k2: float = 2.0, k3: float = 3.0):
    if not pd.notna(pbar):
        return (np.nan, np.nan, np.nan)
    sigma = np.sqrt(pbar * (1 - pbar) / n_i)
    return (pbar, pbar + k2 * sigma, pbar + k3 * sigma)

def _build_time_axis(df: pd.DataFrame) -> pd.Series:
    dt = pd.to_datetime(df["date"].dt.date)
    if "time" in df.columns and df["time"].notna().any():
        tt = pd.to_datetime(df["time"], errors="coerce")
        dt = pd.to_datetime(df["date"].dt.date) \
           + pd.to_timedelta(tt.dt.hour.fillna(0).astype(int), "h") \
           + pd.to_timedelta(tt.dt.minute.fillna(0).astype(int), "m") \
           + pd.to_timedelta(tt.dt.second.fillna(0).astype(int), "s")
    off = pd.to_timedelta(pd.to_numeric(df["count"], errors="coerce").fillna(0).astype(int), "s")
    return dt + off

def _norm_status(v):
    if v is None: return None
    t = str(v).strip().lower()
    if t in {"ÌïòÌïú","ÌïòÌïúÏù¥ÌÉà","low","lower","lo"}:  return "low"
    if t in {"ÏÉÅÌïú","ÏÉÅÌïúÏù¥ÌÉà","high","upper","hi"}: return "high"
    return t

# ============================== UI ===============================
def ui_cause():
    return page_ui()

# ============================ SERVER =============================
def server_cause(input, output, session):
    # ÏÉÅÎã®(Ïπ¥Îìú/ÌïÑÌÑ∞)ÏùÄ ÎèôÎ£å Î≤ÑÏ†Ñ Î°úÏßÅ
    df_all = load_quality_from_file()
    df_fault = load_fault_samples()
    var_map = load_var_labels()

    # ----- Í∏∞Î≥∏ ÎÇ†Ïßú: 3/01 ~ 3/12 Î°ú Ï¥àÍ∏∞Ìôî -----
    session.send_input_message("p_start", {"value": str(DEFAULT_START)})
    session.send_input_message("p_end",   {"value": str(DEFAULT_END)})

    # ----- Î™∞Îìú ÏÑ†ÌÉù(‚ÄúÏ†ÑÏ≤¥‚Äù Ìè¨Ìï®) -----
    @render.ui
    def p_mold_ui():
        molds_all_ctest = set()
        if not df_all.empty and "mold_code" in df_all.columns:
            molds_all_ctest = set(df_all["mold_code"].dropna().astype(str).str.strip().unique())

        molds_all_dtrain = set()
        dtrain_full = _read_csv_first(PATHS["DTRAIN"])
        if not dtrain_full.empty:
            dtrain_full = _clean_common(dtrain_full)
            molds_all_dtrain = set(dtrain_full["mold_code"].dropna().astype(str).str.strip().unique())

        molds = sorted(list(
            molds_all_ctest | molds_all_dtrain | set(BASELINE_FILES_PER_MOLD.keys()) | DTRAIN_MOLDS
        ))
        return ui.input_select("p_mold", "Î™∞Îìú", choices=["Ï†ÑÏ≤¥"] + molds,
                               selected=(molds[0] if molds else "Ï†ÑÏ≤¥"),
                               multiple=False)

    # ----- ÏµúÏã† ÎÇ†Ïßú Î≤ÑÌäº: Ï¢ÖÎ£åÏùºÏùÑ Îç∞Ïù¥ÌÑ∞ ÏµúÏã†ÏùºÎ°ú -----
    @reactive.effect
    @reactive.event(input.btn_update_date)
    def _update_end():
        session.send_input_message("p_end", {"value": str(DEFAULT_END)})

    # ----- Dtrain + Ctest Í≤∞Ìï© Îç∞Ïù¥ÌÑ∞(Í∏∞Í∞Ñ ÌïÑÌÑ∞) -----
    @reactive.calc
    @reactive.event(input.btn_apply)
    def data_in_period() -> pd.DataFrame:
        if not input.p_start() or not input.p_end():
            return pd.DataFrame()
        sd = pd.to_datetime(input.p_start()); ed = pd.to_datetime(input.p_end())
        sd, ed = _clamp_date_range(sd, ed)

        parts = []
        dtrain = _read_csv_first(PATHS["DTRAIN"])
        if not dtrain.empty and sd <= SPLIT_DAY:
            dtrain = _clean_common(dtrain)
            parts.append(dtrain[(dtrain["date"] >= sd) & (dtrain["date"] <= min(ed, SPLIT_DAY))])

        if not df_all.empty and ed > SPLIT_DAY:
            parts.append(df_all[(df_all["date"] > SPLIT_DAY) & (df_all["date"] <= ed)])

        if not parts:
            return pd.DataFrame()

        base = pd.concat(parts, ignore_index=True)
        base = base[(base["date"] >= sd) & (base["date"] <= ed)].copy()
        if "mold_code" in base.columns:
            base["mold_code"] = base["mold_code"].astype(str).map(_norm_mold_code)
        return base

    # ----- Í≥µÌÜµ ÌïÑÌÑ∞(‚ÄòÏ†ÑÏ≤¥‚Äô or Î™∞Îìú ÌïÑÌÑ∞) -----
    @reactive.calc
    @reactive.event(input.btn_apply)
    def filt() -> pd.DataFrame:
        base_data = data_in_period()
        if base_data.empty:
            return pd.DataFrame()
        if input.p_mold() in (None, "Ï†ÑÏ≤¥"):
            return base_data
        target = _norm_mold_code(input.p_mold())
        mold_series = base_data.get("mold_code")
        if mold_series is None:
            return pd.DataFrame()
        mask = mold_series.astype(str).map(_norm_mold_code) == target
        return base_data[mask].copy()

    # ----- ÏÑ†ÌÉù ÏöîÏïΩ -----
    @render.text
    @reactive.event(input.btn_apply)
    def sel_summary():
        if not input.p_start() or not input.p_end():
            return "ÏÑ†ÌÉùÍ∞íÏù¥ ÏóÜÏäµÎãàÎã§."
        sd_ts, ed_ts = _clamp_date_range(pd.to_datetime(input.p_start()), pd.to_datetime(input.p_end()))
        if pd.isna(sd_ts) or pd.isna(ed_ts):
            return "ÏÑ†ÌÉùÍ∞íÏù¥ ÏóÜÏäµÎãàÎã§."
        sd = sd_ts.date()
        ed = ed_ts.date()
        mold_txt = "Ï†ÑÏ≤¥ Î™∞Îìú" if input.p_mold() == "Ï†ÑÏ≤¥" else f"Î™∞Îìú {input.p_mold()}"
        return f"[ÏÑ†ÌÉù] {mold_txt} | Í∏∞Í∞Ñ: {sd} ~ {ed}"

    # ========== (A) Î™∞ÎìúÎ≥Ñ ÎàÑÏ†Å ÌòÑÌô©(ÎèôÎ£å) ==========
    def _count_pchart_violations(df_mold_period: pd.DataFrame, mold: str) -> int:
        if df_mold_period.empty:
            return 0
        pbar = learn_pbar_map().get(str(mold), np.nan)
        if not pd.notna(pbar):
            return 0
        k3 = SIGMA_POLICY.get(str(mold), 3.0)
        _, _, UCL3 = make_limits_no_lcl(pbar, NI, k2=2.0, k3=k3)
        dfm = df_mold_period.sort_values([c for c in ["date","time","count"] if c in df_mold_period.columns], kind="mergesort").copy()
        is_A = dfm["tryshot_signal"].eq("A")
        idx_A = dfm.index[is_A]
        roll_def = (dfm.loc[is_A, "passorfail"] == 1).astype(int).rolling(NI, min_periods=NI).sum()
        dfm["p_hat"] = np.nan
        dfm.loc[idx_A[roll_def.notna()], "p_hat"] = roll_def.dropna().to_numpy() / NI
        ser = dfm.dropna(subset=["p_hat"])
        if ser.empty: return 0
        return int((ser["p_hat"] >= UCL3).sum())

    @render.ui
    @reactive.event(input.btn_apply)
    def mold_cards():
        if not input.p_start() or not input.p_end():
            return ui.div("Í∏∞Í∞ÑÏùÑ ÏÑ†ÌÉùÌïòÏÑ∏Ïöî.", style="text-align:center; padding:24px; color:#6b7280;")
        sd = pd.to_datetime(input.p_start()); ed = pd.to_datetime(input.p_end())
        sd, ed = _clamp_date_range(sd, ed)

        molds_all_ctest = set()
        if not df_all.empty and "mold_code" in df_all.columns:
            molds_all_ctest = {_norm_mold_code(v) for v in df_all["mold_code"].dropna()}
        molds_all_dtrain = set()
        dtrain_full = _read_csv_first(PATHS["DTRAIN"])
        if not dtrain_full.empty:
            dtrain_full = _clean_common(dtrain_full)
            molds_all_dtrain = {_norm_mold_code(v) for v in dtrain_full["mold_code"].dropna()}
        molds_union = (
            molds_all_ctest
            | molds_all_dtrain
            | {_norm_mold_code(k) for k in BASELINE_FILES_PER_MOLD.keys()}
            | {_norm_mold_code(k) for k in DTRAIN_MOLDS}
        )
        molds_to_display = sorted(molds_union)
        if not molds_to_display:
            return ui.div("ÌëúÏãúÌï† Î™∞Îìú Ï†ïÎ≥¥Í∞Ä ÏóÜÏäµÎãàÎã§.", style="text-align:center; padding:24px; color:#6b7280;")

        base = data_in_period()

        fault_counts = {}
        fault_src = load_fault_samples()
        if not fault_src.empty:
            fault_period = fault_src.copy()
            fault_period["date"] = pd.to_datetime(fault_period.get("date"), errors="coerce")
            fault_period = fault_period[(fault_period["date"] >= sd) & (fault_period["date"] <= ed)]

            mold_series = fault_period.get("mold_code")
            if mold_series is not None:
                fault_period["mold_code"] = mold_series.map(_norm_mold_code)
            else:
                fault_period["mold_code"] = ""

            def _calc_fault_count(df_fault: pd.DataFrame) -> int:
                if df_fault.empty:
                    return 0
                if "passorfail" in df_fault.columns:
                    pf = pd.to_numeric(df_fault["passorfail"], errors="coerce").fillna(0)
                    if not pf.empty:
                        gt_zero = int((pf > 0).sum())
                        summed = float(pf.clip(lower=0).sum())
                        return max(int(round(summed)), gt_zero)
                return int(df_fault.shape[0])

            if not fault_period.empty:
                for mold_key, grp in fault_period.groupby("mold_code"):
                    fault_counts[_norm_mold_code(mold_key)] = _calc_fault_count(grp)

        def _card(mold: str):
            mold_key = _norm_mold_code(mold)
            if base.empty or "mold_code" not in base.columns:
                sub = pd.DataFrame()
            else:
                mask = base["mold_code"].astype(str).map(_norm_mold_code) == mold_key
                sub = base[mask].copy()
            fault_cnt = max(int(fault_counts.get(mold_key, 0)), 0)

            if sub.empty:
                return ui.card(
                    ui.card_header(f"Î™∞Îìú {mold}"),
                    ui.div(
                        ui.div("ÎàÑÏ†Å Î∂àÎüâÎ•†", style="text-align:center; color:#6b7280; font-weight:600;"),
                        ui.div("N/A", style="text-align:center; font-weight:800; font-size:26px; color:#9ca3af;"),
                        style="padding:8px 0;"
                    ),
                    ui.div(
                        ui.div(
                            ui.span(f"ÎàÑÏ†Å Î∂àÎüâ {fault_cnt:,} Í±¥"),
                            style="text-align:center; font-size:13px; font-weight:700;"
                        ),
                        style="padding:4px 0 8px 0;"
                    ),
                    style="flex:1 1 260px; min-width:240px; background-color:#f9fafb; opacity:0.8;"
                )

            n_all = int(sub.shape[0]); d_all = int((sub["passorfail"] == 1).sum())
            rate_all = (d_all / n_all * 100.0) if n_all > 0 else 0.0

            return ui.card(
                ui.card_header(f"Î™∞Îìú {mold}"),
                ui.div(
                    ui.div("ÎàÑÏ†Å Î∂àÎüâÎ•†", style="text-align:center; color:#6b7280; font-weight:600;"),
                    ui.div(f"{rate_all:,.2f}%", style="text-align:center; font-weight:800; font-size:26px; color:#1f60c4;"),
                    style="padding:8px 0;"
                ),
                ui.div(
                    ui.div(
                        ui.span(f"ÎàÑÏ†Å Î∂àÎüâ {fault_cnt:,} Í±¥"),
                        style="text-align:center; font-size:13px; font-weight:700;"
                    ),
                    style="padding:4px 0 8px 0;"
                ),
                style="flex:1 1 260px; min-width:240px;"
            )

        return ui.div(
            *[_card(m) for m in molds_to_display],
            style="display:flex; gap:12px; justify-content:flex-start; flex-wrap:nowrap; margin:0 auto; overflow-x:auto; padding-bottom:10px;"
        )

    # ======================= (Î∂ÑÏÑùÎ∂ÄÌÑ∞ ÏïÑÎûòÎäî Í∏∞Ï°¥ Ïú†ÏßÄ) =======================

    # ========== (B) p-Í¥ÄÎ¶¨ÎèÑ ==========  ‚Äî ÏÉâÏÉÅ/Ï†êÏÑ† Ïä§ÌÉÄÏùº Ï†ÅÏö©
    @render.ui
    @reactive.event(input.btn_apply)
    def p_chart():
        mold_sel = input.p_mold()
        if mold_sel in (None, ""):
            return ui.div("Î™∞ÎìúÎ•º ÏÑ†ÌÉùÌïòÏÑ∏Ïöî.", style="padding:12px; color:#6b7280;")
        mold = str(mold_sel)
        mold_norm = _norm_mold_code(mold)
        sd = pd.to_datetime(input.p_start()); ed = pd.to_datetime(input.p_end())
        sd, ed = _clamp_date_range(sd, ed)

        df = filt()
        if df.empty:
            fig = go.Figure(); fig.add_annotation(text="ÏÑ†ÌÉùÌïú Ï°∞Í±¥Ïùò Îç∞Ïù¥ÌÑ∞Í∞Ä ÏóÜÏäµÎãàÎã§.", showarrow=False)
            fig.update_layout(template="plotly_white", height=420)
            return fig_html(fig, 420)

        if mold == "Ï†ÑÏ≤¥":
            fault_df = fault_filt()
            if fault_df.empty or ("Î©îÏãúÏßÄ" in fault_df.columns and len(fault_df.columns) == 1):
                return ui.div(
                    "ÏÑ†ÌÉùÌïú Í∏∞Í∞ÑÏóê Î∂àÎüâ Î°úÍ∑∏Í∞Ä ÏóÜÏñ¥ Ï†ÑÏ≤¥ Î™∞Îìú p-Í¥ÄÎ¶¨ÎèÑÎ•º Í∑∏Î¶¥ Ïàò ÏóÜÏäµÎãàÎã§.",
                    style="padding:12px; color:#6b7280;"
                )
            mold_col = fault_df.get("mold_code")
            if mold_col is not None:
                mold_series = mold_col.dropna().astype(str)
            else:
                mold_series = pd.Series(dtype=str)
            molds_focus = sorted({_norm_mold_code(m) for m in mold_series})
            if molds_focus:
                df = df[df["mold_code"].astype(str).map(_norm_mold_code).isin(molds_focus)]
            if df.empty:
                return ui.div(
                    "ÏÑ†ÌÉùÌïú Í∏∞Í∞ÑÏùò Î∂àÎüâ Î°úÍ∑∏ÏôÄ ÏùºÏπòÌïòÎäî ÌíàÏßà Îç∞Ïù¥ÌÑ∞Í∞Ä ÏóÜÏäµÎãàÎã§.",
                    style="padding:12px; color:#6b7280;"
                )
        else:
            if "mold_code" in df.columns:
                mask = df["mold_code"].astype(str).map(_norm_mold_code) == mold_norm
                df = df[mask]
            if df.empty:
                fig = go.Figure(); fig.add_annotation(text="ÏÑ†ÌÉùÌïú Î™∞ÎìúÏùò Îç∞Ïù¥ÌÑ∞Í∞Ä ÏóÜÏäµÎãàÎã§.", showarrow=False)
                fig.update_layout(template="plotly_white", height=420)
                return fig_html(fig, 420)

        df = df.sort_values([c for c in ["date","time","count"] if c in df.columns], kind="mergesort")
        df["_ts"] = _build_time_axis(df)

        is_A = df["tryshot_signal"].eq("A")
        idx_A = df.index[is_A]
        roll_def = (df.loc[is_A, "passorfail"] == 1).astype(int).rolling(window=NI, min_periods=NI).sum()
        df["p_hat"] = np.nan
        df.loc[idx_A[roll_def.notna()], "p_hat"] = roll_def.dropna().to_numpy() / NI

        ser = df.dropna(subset=["p_hat"]).copy()
        if ser.empty:
            fig = go.Figure(); fig.add_annotation(text="Î°§ÎßÅ Ï∞Ω(60ÏÉ∑)ÏùÑ Ï∂©Ï°±ÌïòÎäî A ÏãúÍ∑∏ÎÑêÏù¥ ÏóÜÏäµÎãàÎã§.", showarrow=False)
            fig.update_layout(template="plotly_white", height=420)
            return fig_html(fig, 420)

        if mold == "Ï†ÑÏ≤¥":
            pbar = pd.to_numeric(df.loc[is_A, "passorfail"], errors="coerce").mean()
            if not pd.notna(pbar):
                fig = go.Figure(); fig.add_annotation(text="Ï†ÑÏ≤¥ Î™∞Îìú Í∏∞Ï§Ä pÃÑ Í∞íÏù¥ Í≥ÑÏÇ∞ÎêòÏßÄ ÏïäÏïòÏäµÎãàÎã§.", showarrow=False)
                fig.update_layout(template="plotly_white", height=420)
                return fig_html(fig, 420)
            k3 = 3.0
            title_txt = f"Ï†ÑÏ≤¥ Î™∞Îìú ÌÜµÌï© p-Í¥ÄÎ¶¨ÎèÑ (n={NI})"
            y_title = "pÃÇ(ÏµúÍ∑º Î∂àÎüâÎ•†)"
        else:
            pbar = learn_pbar_map().get(mold_norm, np.nan)
            if not pd.notna(pbar):
                fig = go.Figure(); fig.add_annotation(text="Ìï¥Îãπ Î™∞ÎìúÏùò Í∏∞Ï§Ä pÃÑÏùÑ ÌïôÏäµÌï† Ïàò ÏóÜÏäµÎãàÎã§.", showarrow=False)
                fig.update_layout(template="plotly_white", height=420)
                return fig_html(fig, 420)
            k3 = SIGMA_POLICY.get(mold_norm, 3.0)
            title_txt = f"Î™∞Îìú {mold} p-Í¥ÄÎ¶¨ÎèÑ (n={NI})"
            y_title = f"pÃÇ(Íµ¨Í∞Ñ n={NI} Î∂àÎüâÎ•†)"
        CL, UCL2, UCL3 = make_limits_no_lcl(pbar, NI, k2=2.0, k3=k3)

        fig = go.Figure()
        # Ï∂îÏÑ∏ÏÑ†(ÌïòÎäòÏÉâ)
        fig.add_trace(go.Scatter(
            x=ser["_ts"], y=ser["p_hat"], mode="lines",
            line=dict(color="#60A5FA", width=1.6),
            name="pÃÇ trend", hoverinfo="skip"
        ))
        # CAUTION / CRITICAL
        cau = ser[(ser["p_hat"] >= UCL2) & (ser["p_hat"] < UCL3)]
        if not cau.empty:
            fig.add_trace(go.Scatter(
                x=cau["_ts"], y=cau["p_hat"], mode="markers",
                marker=dict(size=7, color="#F59E0B"),
                name="CAUTION",
                hovertemplate="ÏãúÍ∞Å:%{x|%Y-%m-%d %H:%M:%S}<br>pÃÇ:%{y:.4f}<extra></extra>"
            ))
        crit = ser[ser["p_hat"] >= UCL3]
        if not crit.empty:
            fig.add_trace(go.Scatter(
                x=crit["_ts"], y=crit["p_hat"], mode="markers",
                marker=dict(size=8, color="#EF4444"),
                name="CRITICAL",
                hovertemplate="ÏãúÍ∞Å:%{x|%Y-%m-%d %H:%M:%S}<br>pÃÇ:%{y:.4f}<extra></extra>"
            ))
        # Í∏∞Ï§ÄÏÑ†(Ï†êÏÑ†)
        fig.add_hline(y=CL,   line=dict(color="#1D4ED8", width=2), line_dash="dot",
                      annotation_text=f"CL ({CL:.3f})", annotation_position="right")
        fig.add_hline(y=UCL2, line=dict(color="#F59E0B", width=2), line_dash="dot",
                      annotation_text=f"UCL2 (2œÉ, {UCL2:.3f})", annotation_position="right")
        fig.add_hline(y=UCL3, line=dict(color="#EF4444", width=2), line_dash="dot",
                      annotation_text=f"UCL3 ({int(k3)}œÉ, {UCL3:.3f})", annotation_position="right")
        fig.update_layout(template="plotly_white", height=420,
                          title=title_txt,
                          hovermode="x unified", margin=dict(l=40, r=20, t=40, b=40),
                          xaxis_title="ÏãúÍ∞Ñ", yaxis_title=y_title,
                          legend=dict(orientation="h", yanchor="bottom", y=1.02, xanchor="right", x=1))
        return fig_html(fig, 420)

    # ========== (C) SHAP Ï§ëÏöî Î≥ÄÏàò Í∏∞Ïó¨ÎèÑ ==========  ‚Äî ‚úÖ ÎèôÎ£å Î≤ÑÏ†Ñ Ï±ÑÌÉù
    # ========== (C) SHAP Ï§ëÏöî Î≥ÄÏàò Í∏∞Ïó¨ÎèÑ ==========  ‚Äî fault_analysis_dataframe_filtered.csv Í∏∞Î∞ò (ÏµúÏÜå ÏàòÏ†ï)
    @render.ui
    @reactive.event(input.btn_apply)
    def shap_plot():
        mold_sel = input.p_mold()
        if mold_sel is None:
            return ui.div(
                "Î™∞ÎìúÎ•º ÏÑ†ÌÉùÌïòÏÑ∏Ïöî.",
                style="color:#6b7280; padding:12px; height: 420px; display:flex; align-items:center; justify-content:center;"
            )

        # Î∂àÎüâ ÏÉòÌîå Î°úÍ∑∏(ÎèôÎ£å ÏΩîÎìúÏùò Îç∞Ïù¥ÌÑ∞ Í≤ΩÎ°ú) ÏÇ¨Ïö© ‚Äî Ïó¨Í∏∞ÏÑú fault_analysis_dataframe_filtered.csvÍ∞Ä Î°úÎìúÎê®
        dff = fault_filt()
        if dff.empty or ("Î©îÏãúÏßÄ" in dff.columns and len(dff.columns) == 1):
            return ui.div(
                "ÏÑ†ÌÉùÌïú Î™∞Îìú/Í∏∞Í∞ÑÏóê SHAP Îç∞Ïù¥ÌÑ∞Í∞Ä ÏóÜÏäµÎãàÎã§.",
                style="color:#6b7280; padding:12px; height: 420px; display:flex; align-items:center; justify-content:center;"
            )

        # 1) CSV ÎÇ¥ Î™®Îì† *_shap Ïª¨Îüº ÏûêÎèô ÌÉêÏßÄ
        shap_cols = [c for c in dff.columns if isinstance(c, str) and c.lower().endswith("_shap")]
        if not shap_cols:
            return ui.div(
                "Îç∞Ïù¥ÌÑ∞Ïóê *_shap Ïª¨ÎüºÏù¥ ÏóÜÏñ¥ SHAP Ï§ëÏöîÎèÑÎ•º Í≥ÑÏÇ∞Ìï† Ïàò ÏóÜÏäµÎãàÎã§.",
                style="color:#6b7280; padding:12px; height: 420px; display:flex; align-items:center; justify-content:center;"
            )

        # 2) Ï†ÑÏó≠ Ï§ëÏöîÎèÑ: Í∞Å Î≥ÄÏàò SHAPÏùò |Í∞í| ÌèâÍ∑†
        df_shap = dff[shap_cols].apply(pd.to_numeric, errors="coerce")
        imp = df_shap.abs().mean(axis=0, skipna=True)  # Series(index=*_shap, value=abs-mean)

        # 3) Î≥ÄÏàòÎ™Ö Ï†ïÎ¶¨ Î∞è ÌïúÍ∏Ä ÎùºÎ≤® Îß§Ìïë
        def base_name(col):
            # ÎÅùÏùò "_shap" Ï†úÍ±∞
            name = col[:-5] if col.lower().endswith("_shap") else col
            # var_labels.csv Îß§Ìïë (ÏÜåÎ¨∏Ïûê ÌÇ§ÎèÑ ÎåÄÏùë)
            return var_map.get(name, var_map.get(name.lower(), name))

        imp_df = (
            imp.rename(index=base_name)
            .reset_index()
            .rename(columns={"index": "Î≥ÄÏàò", 0: "Ï§ëÏöîÎèÑ"})
            .sort_values("Ï§ëÏöîÎèÑ", ascending=False)
        )

        # 4) ÏÉÅÏúÑ 15Í∞úÎßå ÏãúÍ∞ÅÌôî (ÏàòÎüâÏùÄ ÌïÑÏöî Ïãú Ï°∞Ï†à Í∞ÄÎä•)
        topn = imp_df.head(15).reset_index(drop=True)
        values = topn["Ï§ëÏöîÎèÑ"].astype(float)
        if not values.empty and values.max() != values.min():
            marker_style = dict(
                color=values.tolist(),
                colorscale=[(0.0, "#BFDBFE"), (1.0, "#1D4ED8")],
                showscale=False
            )
        else:
            marker_style = dict(color="#1D4ED8")

        # 5) Plotly Î∞îÏ∞®Ìä∏ (Í∞ÄÎèÖÏÑ± ÏúÑÌï¥ Í∞ÄÎ°úÎßâÎåÄ)
        fig = go.Figure()
        fig.add_trace(go.Bar(
            x=topn["Ï§ëÏöîÎèÑ"].values.tolist(),
            y=topn["Î≥ÄÏàò"].values.tolist(),
            orientation="h",
            hovertemplate="%{y}<br>ÌèâÍ∑† |SHAP|: %{x:.5f}<extra></extra>",
            marker=marker_style
        ))
        fig.update_layout(
            template="plotly_white",
            height=420,
            margin=dict(l=120, r=20, t=30, b=40),
            title=f"SHAP Ï§ëÏöî Î≥ÄÏàò Í∏∞Ïó¨ÎèÑ (ÌèâÍ∑† |SHAP|){' - Ï†ÑÏ≤¥ Î™∞Îìú' if mold_sel == 'Ï†ÑÏ≤¥' else f' - Î™∞Îìú {mold_sel}'}",
            xaxis_title="ÌèâÍ∑† |SHAP|",
            yaxis_title="Î≥ÄÏàò",
            yaxis=dict(
                categoryorder="array",
                categoryarray=topn["Î≥ÄÏàò"].tolist(),
                autorange="reversed"
            ),
            showlegend=False
        )

        return fig_html(fig, 420)


    # ========== (D) Ïã§Ï†ú Î∂àÎüâ ÏÉòÌîå Î°úÍ∑∏ ==========  ‚Äî Í∏∞Ï°¥ Ïú†ÏßÄ
    def _ko_var(text: str) -> str:
        if not isinstance(text, str): return text
        s = text.strip()
        if ":" in s:
            h, t = s.split(":", 1)
            return f"{var_map.get(h.strip(), h.strip())}: {t.strip()}"
        return var_map.get(s, s)

    @reactive.calc
    @reactive.event(input.btn_apply)
    def fault_filt():
        if not input.p_start() or not input.p_end():
            return pd.DataFrame({"Î©îÏãúÏßÄ": ["Í∏∞Í∞ÑÏùÑ ÏÑ†ÌÉùÌïòÏÑ∏Ïöî."]})
        df = load_fault_samples().copy()
        if df.empty:
            return pd.DataFrame({"Î©îÏãúÏßÄ": ["Î∂àÎüâ ÏÉòÌîå CSVÍ∞Ä ÎπÑÏñ¥ÏûàÏäµÎãàÎã§."]})
        sd = pd.to_datetime(input.p_start()); ed = pd.to_datetime(input.p_end())
        if sd > ed: sd, ed = ed, sd
        df["date"] = pd.to_datetime(df.get("date"), errors="coerce")
        df = df[(df["date"] >= sd) & (df["date"] <= ed)]
        mold_series = df.get("mold_code")
        if mold_series is not None:
            df["mold_code"] = mold_series.astype(str).map(_norm_mold_code)
        if input.p_mold() not in (None, "Ï†ÑÏ≤¥"):
            if "mold_code" not in df.columns:
                return pd.DataFrame({"Î©îÏãúÏßÄ": ["CSVÏóê Î™∞Îìú ÏΩîÎìúÍ∞Ä ÏóÜÏäµÎãàÎã§."]})
            df = df[df["mold_code"] == _norm_mold_code(input.p_mold())]
        return df.sort_values("date").reset_index(drop=True)

    @render.ui
    @reactive.event(input.btn_apply)
    def detect_log():
        df = fault_filt()
        if df.empty or ("Î©îÏãúÏßÄ" in df.columns and len(df.columns) == 1):
            return ui.HTML(f'<div style="max-height:280px; overflow:auto">{pd.DataFrame(df).to_html(index=False)}</div>')

        def pick(cands):
            low = {c.lower(): c for c in df.columns}
            for n in cands:
                if n.lower() in low: return low[n.lower()]
            return None

        k_date  = pick(["date","ÏùºÏãú","datetime","timestamp","time"])
        k_mold  = pick(["mold_code","mold","Î™∞Îìú"])
        k_count = pick(["count","ÏàúÎ≤à","index","shot_no","shotno"])
        k_rfp   = pick(["rf_prediction","ÏòàÏ∏°Î∂àÎüâÎèÑ","rf_pred"])
        k_rfpb  = pick(["rf_probability","ÏòàÏ∏°Î∂àÎüâÌôïÎ•†","prob","probability"])
        k_s1    = pick(["shap1"]); k_s2 = pick(["shap2"])
        k_s1st  = pick(["shap1_status","shap1Î≥ÄÏàòÏÉÅÌÉú"])
        k_s2st  = pick(["shap2_status","shap2Î≥ÄÏàòÏÉÅÌÉú"])
        k_cut   = pick(["cutoff","Ïù¥ÌÉàÎ≥ÄÏàò"])
        k_if    = pick(["if_prediction","Ïù¥ÏÉÅÌÉêÏßÄ"])
        k_ifas  = pick(["if_anomaly_score","anomalyscore","anomaly_score"])

        def ensure(src): return df[src] if src is not None else pd.Series([None]*len(df))
        out = pd.DataFrame({
            "ÏùºÏãú": pd.to_datetime(ensure(k_date), errors="coerce"),
            "Î™∞Îìú": ensure(k_mold).astype(str) if k_mold else pd.Series([None]*len(df)),
            "ÏàúÎ≤à": pd.to_numeric(ensure(k_count), errors="coerce"),
            "ÏòàÏ∏°Î∂àÎüâÎèÑ": pd.to_numeric(ensure(k_rfp),  errors="coerce"),
            "ÏòàÏ∏°Î∂àÎüâÌôïÎ•†": pd.to_numeric(ensure(k_rfpb), errors="coerce"),
            "shap1": ensure(k_s1), "shap2": ensure(k_s2),
            "shap1Î≥ÄÏàòÏÉÅÌÉú": ensure(k_s1st), "shap2Î≥ÄÏàòÏÉÅÌÉú": ensure(k_s2st),
            "Ïù¥ÌÉàÎ≥ÄÏàò": ensure(k_cut),
            "Ïù¥ÏÉÅÌÉêÏßÄ": ensure(k_if),
            "AnomalyScore": pd.to_numeric(ensure(k_ifas), errors="coerce"),
        })

        for c in ["shap1","shap2"]:
            if c in out: out[c] = out[c].map(_ko_var)
        for c in ["shap1Î≥ÄÏàòÏÉÅÌÉú","shap2Î≥ÄÏàòÏÉÅÌÉú"]:
            if c in out: out[c] = out[c].map(_norm_status)

        def fmt_cut(cell):
            if cell is None or (isinstance(cell, float) and pd.isna(cell)): return None
            try:
                d = cell if isinstance(cell, dict) else (ast.literal_eval(str(cell)) if str(cell).strip() else None)
            except Exception:
                d = None
            if not isinstance(d, dict): return str(cell)
            items = [f"{var_map.get(str(k).strip(), str(k).strip())}: {_norm_status(v)}" for k, v in d.items()]
            return "<br>".join(items)

        if "Ïù¥ÌÉàÎ≥ÄÏàò" in out: out["Ïù¥ÌÉàÎ≥ÄÏàò"] = out["Ïù¥ÌÉàÎ≥ÄÏàò"].map(fmt_cut)
        if out["ÏùºÏãú"].notna().any(): out = out.sort_values("ÏùºÏãú").reset_index(drop=True)
        if "ÏòàÏ∏°Î∂àÎüâÌôïÎ•†" in out: out["ÏòàÏ∏°Î∂àÎüâÌôïÎ•†"] = out["ÏòàÏ∏°Î∂àÎüâÌôïÎ•†"].round(4)
        if "AnomalyScore" in out:  out["AnomalyScore"]  = out["AnomalyScore"].round(3)

        def map_if(x):
            s = str(x).strip().lower()
            if s in {"1","true","yes","y","anomaly","abnormal","Ïù¥ÏÉÅ"}: return "Ïù¥ÏÉÅ"
            if s in {"0","false","no","n","normal","Ï†ïÏÉÅ"}:            return "Ï†ïÏÉÅ"
            return None
        if "Ïù¥ÏÉÅÌÉêÏßÄ" in out: out["Ïù¥ÏÉÅÌÉêÏßÄ"] = out["Ïù¥ÏÉÅÌÉêÏßÄ"].map(map_if)

        html = out.to_html(index=False, border=0, classes="tbl-sample-log", escape=False)
        html = html.replace(">\n<thead", ">\n<caption>Ïã§Ï†ú Î∂àÎüâ ÏÉòÌîå Î°úÍ∑∏</caption>\n<thead", 1)
        return ui.HTML(f"""
        <style>
        .tbl-wrap {{ max-height:280px; overflow-y:auto; border:1px solid #e5e7eb; border-radius:6px; }}
        table.tbl-sample-log {{ width:100%; table-layout:fixed; border-collapse:collapse; font-size:13px; }}
        table.tbl-sample-log caption {{ caption-side:top; text-align:center; font-weight:700; padding:6px 0 4px; }}
        table.tbl-sample-log thead th {{ text-align:left; position:sticky; top:0; background:#fff; z-index:1; border-bottom:1px solid #e5e7eb; padding:8px 10px; font-weight:700; }}
        table.tbl-sample-log tbody td {{ text-align:left; vertical-align:top; padding:8px 10px; border-bottom:1px solid #f1f5f9; word-break:break-word; font-variant-numeric:tabular-nums; }}
        </style>
        <div class="tbl-wrap">{html}</div>
        """)

    # ‚úÖ CSV Îã§Ïö¥Î°úÎìú (ÏÉòÌîå Î°úÍ∑∏ Í∑∏ÎåÄÎ°ú Ï†ÄÏû•)
    @render.download(filename=lambda: f"sample_log_{input.p_mold() or 'ALL'}_{input.p_start() or 'NA'}_{input.p_end() or 'NA'}.csv")
    def btn_report():
        df = fault_filt()
        yield df.to_csv(index=False, encoding="utf-8-sig").encode("utf-8-sig")

    # ========== (E) Î≥ÄÏàòÎ≥Ñ Í¥ÄÍ≥ÑÎ∂ÑÏÑù(TOP5) ‚Äî Score Ïú†ÏßÄ ==========
    @reactive.calc
    @reactive.event(input.btn_apply)
    def var_relation_df():
        df = fault_filt()
        if df.empty or ("Î©îÏãúÏßÄ" in df.columns and len(df.columns) == 1):
            return pd.DataFrame(columns=["Î≥ÄÏàò","ÏÉÅÌÉú","shap","high","low","Score","rank"])

        def pick(cands):
            low = {c.lower(): c for c in df.columns}
            for n in cands:
                if n.lower() in low: return low[n.lower()]
            return None

        k_cut = pick(["cutoff","Ïù¥ÌÉàÎ≥ÄÏàò"])
        k_s1, k_s2 = pick(["shap1"]), pick(["shap2"])
        k_s1st = pick(["shap1_status","shap1Î≥ÄÏàòÏÉÅÌÉú"])
        k_s2st = pick(["shap2_status","shap2Î≥ÄÏàòÏÉÅÌÉú"])

        def nstat(v):
            t = str(v).strip().lower()
            if t in {"ÌïòÌïú","ÌïòÌïúÏù¥ÌÉà","low","lower","lo"}: return "low"
            if t in {"ÏÉÅÌïú","ÏÉÅÌïúÏù¥ÌÉà","high","upper","hi"}: return "high"
            return None

        cutoff, shap = {}, {}
        if k_cut:
            for cell in df[k_cut]:
                if cell is None or (isinstance(cell,float) and pd.isna(cell)): continue
                try:
                    d = cell if isinstance(cell, dict) else (ast.literal_eval(str(cell)) if str(cell).strip() else None)
                except Exception:
                    d = None
                if not isinstance(d, dict): continue
                for k, v in d.items():
                    st = nstat(v)
                    if st not in {"low","high"}: continue
                    vko = var_map.get(str(k).strip(), str(k).strip())
                    cutoff[(vko, st)] = cutoff.get((vko, st), 0) + 1

        def add_shap(name_val, status_val):
            if not isinstance(name_val, str) or status_val is None: return
            var_name = name_val.split(":",1)[0].strip()
            vko = var_map.get(var_name, var_name)
            st  = nstat(status_val)
            if st not in {"low","high"}: return
            shap[(vko, st)] = shap.get((vko, st), 0) + 1

        for _, r in df.iterrows():
            if k_s1: add_shap(r.get(k_s1), r.get(k_s1st))
            if k_s2: add_shap(r.get(k_s2), r.get(k_s2st))

        vars_all = set(v for v,_ in cutoff.keys()) | set(v for v,_ in shap.keys())
        rows = []
        for v in vars_all:
            for st in ["high","low"]:
                s = shap.get((v,st), 0)
                h = cutoff.get((v,"high"), 0) if st == "high" else 0
                l = cutoff.get((v,"low"),  0) if st == "low"  else 0
                rows.append({"Î≥ÄÏàò": v, "ÏÉÅÌÉú": st, "shap": s, "high": h, "low": l, "Score": s + h + l})

        out = pd.DataFrame(rows)
        if out.empty:
            return pd.DataFrame(columns=["Î≥ÄÏàò","ÏÉÅÌÉú","shap","high","low","Score","rank"])
        out = out.sort_values(["Score","shap","high","low"], ascending=[False,False,False,False]).reset_index(drop=True)
        out["rank"] = out.index + 1
        return out.head(5)

    @render.ui
    @reactive.event(input.btn_apply)
    def var_rel_table():
        df_top = var_relation_df()
        if df_top.empty:
            return ui.HTML('<div style="padding:8px;color:#6b7280;">Îç∞Ïù¥ÌÑ∞Í∞Ä ÏóÜÏäµÎãàÎã§.</div>')

        pretty = df_top[["rank","Î≥ÄÏàò","Score","ÏÉÅÌÉú","shap","high","low"]].rename(columns={
            "rank":"Rank","Î≥ÄÏàò":"Î≥ÄÏàò","Score":"ÏõêÏù∏ Í∏∞Ïó¨ ÌöüÏàò","ÏÉÅÌÉú":"ÏÉÅÌÉú","shAP":"SHAPÌöüÏàò","high":"HIGHÌöüÏàò","low":"LOWÌöüÏàò"
        })
        # Ïò§ÌÉÄ Î∞©ÏßÄ Ïû¨Ï†ïÏùò
        pretty = df_top[["rank","Î≥ÄÏàò","Score","ÏÉÅÌÉú","shap","high","low"]].rename(columns={
            "rank":"Rank","Î≥ÄÏàò":"Î≥ÄÏàò","Score":"ÏõêÏù∏ Í∏∞Ïó¨ ÌöüÏàò","ÏÉÅÌÉú":"ÏÉÅÌÉú","shap":"SHAPÌöüÏàò","high":"HIGHÌöüÏàò","low":"LOWÌöüÏàò"
        })

        html = pretty.to_html(index=False, classes="var-rel-table", border=0)
        return ui.HTML(f"""
        <style>
        table.var-rel-table {{
            width: 100%;
            border-collapse: collapse;
            font-size: 14px;
        }}
        table.var-rel-table thead th {{
            text-align: left;
            border-bottom: 1px solid #e5e7eb;
            padding: 8px 10px;
            font-weight: 700;
        }}
        table.var-rel-table tbody td {{
            text-align: left;
            padding: 10px 10px;
            border-bottom: 1px solid #f1f5f9;
            font-variant-numeric: tabular-nums;
        }}
        td.rank-cell::before {{
            content: attr(data-rank);
            display: inline-block;
            min-width: 36px;
            text-align: center;
            background: #111827;
            color: #fff;
            border-radius: 16px;
            padding: 2px 10px;
            font-weight: 800;
            letter-spacing: 0.5px;
        }}
        td.rank-cell[data-rank="1"]::before {{ background:#D4AF37; color:#111; }}
        td.rank-cell[data-rank="2"]::before {{ background:#C0C0C0; color:#111; }}
        td.rank-cell[data-rank="3"]::before {{ background:#CD7F32; color:#111; }}
        td.state-cell[data-state="low"]  {{ color:#2E86C1; font-weight:700; }}
        td.state-cell[data-state="high"] {{ color:#E74C3C; font-weight:700; }}
        td.score-cell {{ font-weight: 900; font-size: 18px; letter-spacing: 0.2px; }}
        </style>
        {html}
        <script>
        (function(){{
            var tbl = document.querySelector('table.var-rel-table'); if(!tbl) return;
            var rows = tbl.tBodies[0]?.rows || [];
            Array.from(rows).forEach(function(row){{
                var rankTd = row.cells[0];
                if(rankTd){{
                    var rk=(rankTd.innerText||'').trim();
                    rankTd.setAttribute('data-rank',rk);
                    rankTd.classList.add('rank-cell');
                    rankTd.innerText='';
                }}
                var scoreTd = row.cells[2];
                if(scoreTd){{
                    scoreTd.classList.add('score-cell');
                }}
                var stateTd = row.cells[3];
                if(stateTd){{
                    var st=(stateTd.innerText||'').trim().toLowerCase();
                    stateTd.classList.add('state-cell');
                    stateTd.setAttribute('data-state',st);
                }}
            }});
        }})();
        </script>
        """)

    @render.ui
    @reactive.event(input.btn_apply)
    def var_rel_bar():
        df_top = var_relation_df()
        if df_top.empty:
            fig = go.Figure(); fig.add_annotation(text="Îç∞Ïù¥ÌÑ∞ ÏóÜÏùå", showarrow=False)
            fig.update_layout(template="plotly_white", height=340)
            return fig_html(fig, 340)

        # XÏ∂ï: "Î≥ÄÏàòÎ™Ö(Îã®ÏúÑ Ï†úÍ±∞)\n(LOW/HIGH)" ÌòïÏãù
        def norm_label(vname: str):
            s = str(vname)
            return s.split("(")[0].strip()

        x = df_top.apply(lambda r: f"{norm_label(r['Î≥ÄÏàò'])}\n({'HIGH' if r['ÏÉÅÌÉú']=='high' else 'LOW'})", axis=1).tolist()
        y = df_top["Score"].tolist()
        colors = ["#E74C3C" if s == "high" else "#2E86C1" for s in df_top["ÏÉÅÌÉú"]]

        fig = go.Figure()
        fig.add_trace(go.Bar(
            x=x, y=y, marker_color=colors,
            hovertemplate="%{x}<br>ÏõêÏù∏ Í∏∞Ïó¨ ÌöüÏàò: %{y}<extra></extra>",
            name=""
        ))
        # ÏÉâÏÉÅ Î≤îÎ°Ä(LOW/HIGH)
        fig.add_trace(go.Scatter(x=[None], y=[None], mode="markers",
                                 marker=dict(size=10, color="#2E86C1"), name="LOW"))
        fig.add_trace(go.Scatter(x=[None], y=[None], mode="markers",
                                 marker=dict(size=10, color="#E74C3C"), name="HIGH"))

        fig.update_layout(template="plotly_white", height=340,
                          margin=dict(l=40, r=20, t=30, b=70),
                          xaxis_title="Î≥ÄÏàò(ÏÉÅÌÉú)",
                          yaxis_title="ÏõêÏù∏ Í∏∞Ïó¨ ÌöüÏàò",
                          legend=dict(orientation="h", yanchor="bottom", y=1.02, xanchor="right", x=1),
                        #   annotations=[dict(
                        #       x=0, y=-0.28, xref="paper", yref="paper",
                        #     #   text="ÏõêÏù∏ Í∏∞Ïó¨ ÌöüÏàò = SHAPÌöüÏàò + HIGHÌöüÏàò + LOWÌöüÏàò",
                        #       showarrow=False, align="left", font=dict(color="#6b7280")
                        #   )]
                          )
        return fig_html(fig, 340)
